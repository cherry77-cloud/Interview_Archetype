1. TCP服务的特点
◼ 传输层协议主要有两个: TCP协议和UDP协议。TCP协议相对于UDP协议的特点是: 面向连接，字节流和可靠传输.
◼ 使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上
数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源.
◼ TCP协议的这种连接是一对一的，所以基于广播和多播(目标是多个主机地址)的应用程序不能使用TCP服务。而无连接协议UDP则非常适合于
广播和多播.
◼ 应用程序对数据的发送和接收是没有边界限制的。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并
发送之。接收端必须及时针对每一个UDP数据报执行读操作(通过recvfrom)系统调用，否则就会丢包(这经常发生在较慢的服务器上)。并且，
如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断.
◼ TCP传输是可靠的。首先，TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输
成功。其次，TCP协议采用超时重传机制，发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。
最后，因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端可能乱序，重复，所以TCP协议还会对接收到的TCP报文重排，整理，
在交付给应用层.
◼ UDP协议则和IP协议一样，提供不可靠服务。它们都需要上层协议来处理数据确认和超时重传.


2. TCP连接的建立和关闭
◼ TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，通信的一端可以发送结束报文段给对方，告诉它本端已经完成了
数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭状态。socket网络编程
接口通过shutdown函数提供了对半关闭的支持.
◼ 如果客户端访问一个距离它很远的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序先进行
重连(可能执行多次)，如果重连仍然无效，则通知应用程序连接超时.
◼ 客户端连接在收到服务器的结束报文段之后，并没有直接进入CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，客户端连接要等待一段
长为2MSL的时间，才能完全关闭。MSL是TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min. 
TIME_WAIT状态存在的原因有两点:
    ● 可靠地终止TCP连接.
    ● 保证让迟来的TCP报文段有足够的时间被识别并丢弃.


3. TCP状态转移
◼ TCP连接的任意一端在任一时刻都处于某种状态，当前状态可以用过netstat命令查看.
◼ 服务器通过listen系统调用进入LISTEN状态，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接
请求(收到同步报文段)，就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态。
如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。ESTABLISHED状态是连接双方能够进行
双向数据传输的状态.
◼ 当客户端主动关闭连接时(通过close或shutdown系统调用向服务器发送结束报文段)，服务器通过返回确认报文段使连接进入
CLOSE_WAIT状态。通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接转移到
LAST_ACK状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了.

◼ 客户端通过connect系统调用主动与服务器建立连接。connect系统调用首先给服务器发送一个同步报文段，使连接转移到SYN_SENT状态。
此后，connect系统调用可能因为如下两个原因失败返回:
    ● 如果connect连接的目标端口不存在(未被任何进程监听)，或者该端口仍被处于TIME_WAIT状态的连接所占用，则服务器将给客户端
      发送一个复位报文段，connect调用失败.
    ● 如果目标端口存在，但connect在超时时间内未收到服务器的确认报文段，则connect调用失败.
    ● connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，
      连接转移至ESTABLISHED状态.
◼ 当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确认目的
的确认报文段，则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭
的状态。此时如果服务器也关闭连接(发送结束报文段)，则客户端将给予确认并进入TIME_WAIT状态.
◼ 处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状态。如果不是为了
在半关闭状态下继续接收数据，连接长时间地停留在FIN_WAIT_2状态并无益处。连接停留在FIN_WAIT_2状态的情况可能发生在:
    ● 客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接.
    ● Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量: /proc/sys/net/ipv4/tcp_max_orphans 
      和/proc/sys/net/ipv4/tcp_fin_timeout。前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间.
◼ 客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性，临时端口号一般和程序上一次使用的端口号不同，所以客户端程序
一般可以立即重启.


4. 在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接.
◼ 当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段.
◼ 实际上，当客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时，客户端程序也将收到复位报文段.
◼ TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃.
◼ 服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段，此时，客户端(或服务器)还维持着原来的连接，而
服务器(或客户端)即使重启，也已经没有该连接的任何信息。我们将这种状态称为半打开状态，处于这种状态的连接称为半打开连接。
如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方将回应一个复位报文段.


5. TCP交互数据流，带外数据
◼ TCP报文段所携带的应用程序数据按照长度分为两种: 交互数据和成块数据。交互数据仅包含很少的字节。使用交互数据的应用程序(或协议)对
实时性要求高，比如telnet，ssh等。成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序(或协议)对传输效率
要求高，比如ftp.
◼ 有些传输层协议具有带外数据的概念，用于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据有更高的优先级，它应该总是立即
被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的
连接中。实际应用中，带外数据的使用很少见，已知的仅有telnet，ftp等远程非活跃程序.
◼ UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种
紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。


6. TCP超时重传和拥塞控制
◼ TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段
第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器.
◼ Linux有两个重要的内核参数与TCP超时重传相关: /proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2. 
前者指定在底层IP接管之前TCP最少执行的重传次数，默认值是3。后者指定连接放弃前TCP最多可以执行的重传次数，默认值是15.
◼ TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。这就是所谓的拥塞控制。
发送端判断拥塞发生的依据有如下两个:
    ● 传输超时，或者说TCP重传定时器溢出
    ● 接收到重复的确认报文段
◼ TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分: 慢启动，拥塞避免，快速重传和快速恢复。拥塞控制算法在
Linux下有多种实现，比如reno算法，vegas算法和cubic算法等.
