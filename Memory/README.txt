1. 进程虚拟地址空间布局
◼ Text段: 
    ● 包含程序的可执行代码以及只读常量等。
    ● 由于程序代码通常不需要修改，操作系统会将该区域映射为只读，并且可以实现共享(多个进程运行同一份代码时共用一块物理内存)
◼ Data段: 
    ● 存放已初始化的全局变量和静态变量; 
    ● 该区域在编译链接时已知大小，并且存储在可执行文件中
◼ BSS段: 
    ● 用于存放未初始化的全局/静态变量; 
    ● 该区域在编译链接时仅保留大小信息，运行时才被真正分配并清零，故在可执行文件中不会占据实际存储空间
◼ Heap: 
    ● 由动态分配内存（如 malloc、new）使用，堆空间向高地址增长。
    ● 程序运行时可以自由扩展或收缩堆空间(通过系统调用如 brk、sbrk 或更常见的 mmap 方式实现)
◼ 文件映射区: 
    ● 包含动态链接库(共享库)的映射区域和其他由 mmap 系统调用映射的内存区域(如内存映射文件、匿名映射等)
◼ Stack: 
    ● 存放函数调用时的局部变量、返回地址、函数参数等信息，通常向低地址方向扩展
◼ 内核空间: 
    ● 在用户态中不可直接访问内核空间(受操作系统保护)


2. C++内存模型
◼ 栈区:
    ● 栈区常被称为自动存储区(automatic storage), 在 C++ 中主要用于存储局部变量、函数参数、返回地址以及
      编译器在调用/返回过程中需要使用的其他临时信息
    ● 在函数调用时，会在栈上开辟相应大小的空间，用于存储该函数的局部变量和部分调用信息；函数返回后，这块空间被自动释放
    ● 生命周期: 在函数调用时分配，在函数返回后释放，或在花括号作用域结束时自动销毁局部对象
◼ 堆区 / 自由存储区:
    ● 堆: 在通用操作系统层面，常指使用 malloc / free 或系统调用(如 brk / mmap)动态申请和释放的内存区域
    ● 自由存储区: 专指使用 new / delete 操作符进行内存分配和释放的区域
    ● 生命周期: 由程序员决定
◼ 常量存储区
    ● 存储字符串字面量, const 修饰的只读数据等(有些编译器可能将它们放在 .rodata 段或合并到代码段)
    ● 经常与代码区一起被标记为只读(如 .text 和 .rodata)，以防止修改
    ● 生命周期: 在程序运行期间始终存在
◼ 全局 / 静态存储区
    ● 存储已初始化的全局变量和静态变量(编译期已知值), 未初始化的全局变量和静态变量(初始值为 0，通常存放于 BSS 段)
    ● 在 C++ 中，静态不仅可以修饰全局变量，也可以修饰类的静态成员、函数内部的静态局部变量等
    ● 这些变量在程序启动时被分配，在程序结束时被回收，生命周期贯穿整个程序运行期
◼ 代码区
    ● 存储内容: 包含程序的可执行指令(机器码)，以及有时会包含只读的常量(可能也会放到独立的只读区)
    ● 通常被标记为只读，防止程序在运行时修改自身的指令
    ● 可执行文件中，代码段可以被多个进程共享(操作系统会将同一个程序的代码段映射到每个进程的虚拟地址空间里)，从而节省内存
    ● 生命周期: 程序运行时一直存在，直到程序退出
