1. 异常
  ◼ 异常是异常控制流的一种形式, 它一部分由硬件实现, 一部分由操作系统实现.
  ◼ 异常就是控制流中的突变, 用来响应处理器状态中的某些变化.
  ◼ 在任何情况下, 当处理器检测到有事件发生时, 它就会通过一张叫做异常表的跳转表, 进行一个间接过程调用, 到一个专门设计用来
    处理这类事件的操作系统子程序(异常处理程序). 当异常处理程序完成处理后, 根据引起异常的事件的类型, 会发生以下3种情况的一种:
      ● 处理程序将控制返回给当前指令, 即当事件发生时正在执行的指令.
      ● 处理程序将控制返回给下一条指令, 如果没有发生异常将会执行的下一条指令.
      ● 处理程序终止被中断的程序.


2. 异常处理
  ◼ 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号. 其中一些号码是由处理器的设计者分配的, 其他号码是由操作系统
     内核的设计者分配的. 在系统启动时(当计算机重启或者加电时), 操作系统分配和初始化一张称为异常表的跳转表, 使得表目k包含异常k
     的处理程序的地址.
  ◼ 在运行时(当系统在执行某个程序时), 处理器检测到发生了一个事件, 并且确定了相应的异常号k. 随后, 处理器触发异常, 方法是执行
     间接过程调用, 通过异常表的表目k, 转到相应的处理程序.异常号是到异常表中的索引, 异常表的起始地址放在一个叫做异常表基址寄存器
     的特殊CPU寄存器里.


3. 异常的类别
异常可以分为四类: 中断(interrupt), 陷阱(trap), 故障(fault)和终止(abort).
★ 中断: 中断是异步发生的, 是来自处理器外部的I/O设备的信号的结果. 硬件中断不是由任何一条专门的指令造成的, 从这个意义上来说它是异步的.
      硬件中断的异常处理程序常常称为中断处理程序.
★ 陷阱和系统调用: 陷阱是有意的异常, 是执行一条指令的结果. 就像中断处理程序一样, 陷阱处理程序将控制返回到下一条指令. 陷阱最重要的用途
      是在用户程序和内核之间提供像一个过程一样的接口, 叫做系统调用.
  ◼ 用户程序经常需要向内核请求服务, 比如读一个文件(read), 创建一个新的进程(fork), 加载一个新的程序(execve), 或者终止当前进程(exit). 
    为了允许对这些内核服务的受控的访问, 处理器提供了一条特殊的 syscall n 指令, 当用户程序想要请求服务 n 时, 可以执行这条指令. 
    执行syscall指令会导致一个到异常处理程序的陷阱, 这个处理程序解析参数, 并调用适当的内核程序.
★ 故障: 故障由错误情况引起, 它可能能够被故障处理程序修正. 当故障发生时, 处理器将控制转移给故障处理程序. 如果处理程序能够修正这个错误情况, 
     它就将控制返回到引起故障的指令, 从而重新执行它. 否则, 处理程序返回到内核中的abort例程, abort例程会终止引起故障的应用程序.
★ 终止: 终止是不可恢复的致命错误造成的结果, 通常是一些硬件错误, 比如DRAM或者SRAM位被损坏时发生的奇偶错误. 终止处理程序从不将控制返回
     给应用程序.


4. Linux/x86-64 故障和终止
  ◼ 除法错误: Unix 不会试图从除法错误中恢复, 而是选择终止程序; Linux shell 通常会把除法错误报告为"浮点异常".
  ◼ 一般保护故障: 通常是因为一个程序引用了一个未定义的虚拟内存区域, 或者因为程序试图写一个只读的文本段. Linux 不会尝试恢复这类故障. 
    Linux shell 通常会把这种一般保护故障报告为"段错误".
  ◼ 缺页: 重新执行产生故障指令的一个异常示例. 处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面, 然后重新执行这条产生
        故障的指令.
  ◼ 机器检查: 机器检查是在导致故障的指令执行中检测到致命的硬件错误时发生的.


5. Linux/x86-64 系统调用
每个系统调用都有一个唯一的整数号, 对应于一个到内核中跳转表的偏移量.
★ read -> 读文件                write -> 写文件              open -> 打开文件              close -> 关闭文件       
★ mmap -> 将内存页映射到文件     brk -> 重置堆顶              dup2 -> 复制文件描述符         pause -> 挂起进程直到信号到达     
★ alarm -> 调度告警信号的传送    getpid -> 获得进程ID         fork -> 创建进程              execve -> 执行一个程序
★ _exit -> 终止进程             wait4 -> 等待一个进程终止     kill -> 发送信号到一个进程     stat -> 获得文件信息
