1. TCP服务的特点
◼ 传输层协议主要有两个: TCP协议和UDP协议。TCP协议相对于UDP协议的特点是: 面向连接，字节流和可靠传输.
◼ 使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核
资源，以管理连接的状态和连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。
完成数据交换之后，通信双方都必须断开连接以释放系统资源.
◼ TCP协议的这种连接是一对一的，所以基于广播和多播(目标是多个主机地址)的应用程序不能使用TCP服务。而
无连接协议UDP则非常适合于广播和多播.
◼ 应用程序对数据的发送和接收是没有边界限制的。UDP则不然。发送端应用程序每执行一次写操作，
UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作(通过recvfrom)
系统调用，否则就会丢包(这经常发生在较慢的服务器上)。并且，如果用户没有指定足够的应用程序缓冲区来
读取UDP数据，则UDP数据将被截断.
◼ TCP传输是可靠的。首先，TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到
接收方的应答，才认为这个TCP报文段传输成功。其次，TCP协议采用超时重传机制，发送端在发送出一个
TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。最后，因为TCP报文段
最终是以IP数据报发送的，而IP数据报到达接收端可能乱序，重复，所以TCP协议还会对接收到的TCP
报文重排，整理，在交付给应用层.
◼ UDP协议则和IP协议一样，提供不可靠服务。它们都需要上层协议来处理数据确认和超时重传.


2. TCP连接的建立和关闭
◼ TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，通信的一端可以发送结束报文段给对方，
告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。
TCP连接的这种状态称为半关闭状态。socket网络编程接口通过shutdown函数提供了对半关闭的支持.
◼ 如果客户端访问一个距离它很远的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，
此时客户端程序先进行重连(可能执行多次)，如果重连仍然无效，则通知应用程序连接超时.
◼ 客户端连接在收到服务器的结束报文段之后，并没有直接进入CLOSED状态，而是转移到
TIME_WAIT状态。在这个状态，客户端连接要等待一段长为2MSL的时间，才能完全关闭。MSL是TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min. TIME_WAIT状态存在的原因有两点:
    ● 可靠地终止TCP连接.
    ● 保证让迟来的TCP报文段有足够的时间被识别并丢弃.


3. TCP状态转移
◼ TCP连接的任意一端在任一时刻都处于某种状态，当前状态可以用过netstat命令查看.
◼ 服务器通过listen系统调用进入LISTEN状态，被动等待客户端连接，因此执行的是所谓的被动打开。服务器一旦监听到某个连接请求(收到同步报文段)，就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态。如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。ESTABLISHED状态是连接双方能够进行双向数据传输的状态.
◼ 当客户端主动关闭连接时(通过close或shutdown系统调用向服务器发送结束报文段)，服务器通过返回确认报文段使连接进入CLOSE_WAIT状态。通常，服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接转移到LAST_ACK状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接就彻底关闭了.

◼ 客户端通过connect系统调用主动与服务器建立连接。connect系统调用首先给服务器发送
一个同步报文段，使连接转移到SYN_SENT状态。此后，connect系统调用可能因为如下两个原因失败返回:
    ● 如果connect连接的目标端口不存在(未被任何进程监听)，或者该端口仍被处于TIME_WAIT状态的连接所占用，则服务器将给客户端发送一个复位报文段，connect调用失败.
    ● 如果目标端口存在，但connect在超时时间内未收到服务器的确认报文段，则connect调用失败.
    ● connect调用失败将使连接立即返回到初始的CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接转移至ESTABLISHED状态.
◼ 当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确认目的的确认报文段，则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接(发送结束报文段)，则客户端将给予确认并进入TIME_WAIT状态.
◼ 处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状态。如果不是为了在半关闭状态下继续接收数据，连接长时间地停留在FIN_WAIT_2状态并无益处。连接停留在FIN_WAIT_2状态的情况可能发生在:
    ● 客户端执行半关闭后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接.
    ● Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量: /proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/tcp_fin_timeout。前者指定内核能接管的孤儿连接数目，后者指定孤儿连接在内核中生存的时间.
◼ 客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性，临时端口号一般和程序上一次使用的端口号不同，所以客户端程序一般可以立即重启.
