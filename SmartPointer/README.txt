1. C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 new 和 delete 带来的复杂性和错误。智能指针通过 RAII(资源获取即初始化)机制，
在对象生命周期结束时自动释放资源，从而有效防止内存泄漏和资源管理错误。


2. 原生指针
● 内存泄漏(Memory Leak): 如果使用 new 分配了堆内存但忘记在合适的时机调用 delete，就会导致内存泄漏。
● 悬挂指针(Dangling Pointer): 当指针指向的内存已被释放或被其他对象占用后，原生指针却仍然保持不变，后续操作就有可能读写到无效或错误的内存区域。
● 双重释放(Double Free): 如果两个原生指针都指向同一块堆内存，并且都在析构或其他代码中调用了 delete，会发生双重释放错误，导致程序崩溃或出现未定义行为。


3. 智能指针
● 自动销毁: 在智能指针生命周期结束时自动释放资源。
● 引用计数: 共享智能指针能够跟踪引用数量，确保资源在最后一个引用结束时释放。
● 避免内存泄漏: 通过 RAII 机制自动管理资源生命周期。
● 类型安全: 提供更严格的类型检查，减少错误。
● std::unique_ptr: 独占所有权，适合大多数需要动态分配但只有唯一所有者的场景。
● std::shared_ptr: 共享所有权，适合多个对象需要同时使用和管理同一资源的场景。
● std::weak_ptr: 辅助 std::shared_ptr，防止循环引用，并且可用于检测资源是否还存在。


4. std::unique_ptr
◼ 主要特性
● std::unique_ptr 是一种独占所有权的智能指针，任何时刻只能有一个 unique_ptr 实例拥有对某个对象的所有权。不能被拷贝，只能被移动。
● 独占所有权：确保资源在一个所有者下。
● 轻量级：没有引用计数，开销小。
● 自动释放：在指针销毁时自动释放资源。

◼ unique_ptr 提供多种构造函数和赋值操作，以支持不同的使用场景。
● 默认构造函数：创建一个空的 unique_ptr。
● 指针构造函数：接受一个裸指针，拥有其所有权。
● 移动构造函数：将一个 unique_ptr 的所有权转移到另一个 unique_ptr。
● 移动赋值操作符：将一个 unique_ptr 的所有权转移到另一个 unique_ptr。
● 由于 unique_ptr 不能被拷贝，必须通过移动语义转移所有权。这保证了资源的独占性。


5. std::shared_ptr
◼ 主要特性
● std::shared_ptr 是一种共享所有权的智能指针，允许多个 shared_ptr 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。
● 共享所有权：多个 shared_ptr 可以指向同一个对象。
● 引用计数：跟踪有多少 shared_ptr 实例指向同一对象。
● 自动释放：当引用计数为0时，自动释放资源。

◼ 引用计数与控制块
● shared_ptr 背后依赖一个控制块（Control Block），用于存储引用计数和指向实际对象的指针。控制块的主要内容包括：
● 强引用计数（use_count）：表示有多少个 shared_ptr 指向对象。
● 弱引用计数（weak_count）：表示有多少个 weak_ptr 指向对象（不增加强引用计数）。

◼ 构造函数与赋值
● shared_ptr 提供多种构造函数和赋值操作，以支持不同的使用场景。
● 默认构造函数：创建一个空的 shared_ptr。
● 指针构造函数：接受一个裸指针，拥有其所有权。
● 拷贝构造函数：增加引用计数，共享对象所有权。
● 移动构造函数：转移所有权，源 shared_ptr 变为空。
● 拷贝赋值操作符：释放当前资源，增加引用计数，指向新对象。
● 移动赋值操作符：释放当前资源，转移所有权，源 shared_ptr 变为空。
