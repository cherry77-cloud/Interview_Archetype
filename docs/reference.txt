1. 引用的基本概念
● 引用不是对象: 它本身并不占用额外内存空间，不能像指针那样对引用做算术运算或修改它的指向。
● 引用必须初始化: 一旦创建，就必须绑定到某个已存在的对象上，而且绑定后不可改变。
● 通过引用访问对象: 对引用执行的操作，本质上就是对底层对象执行操作。


2. 左值
◼ 左值(lvalue)是指具有明确存储位置（内存地址）的对象，可以出现在赋值表达式的左侧。左值表示对象的身份，即它们是什么。
◼ 有持久的存储位置, 可以被取地址.
◼ 可以出现在赋值操作符的左边。
◼ 典型例子: 变量名, 返回左值引用的函数调用, 前置自增/自减运算符, 赋值/复合赋值表达式, 解引用表达式。


3. 右值
◼ 右值(rvalue)是指临时的, 不具有持久存储位置的对象, 通常是无法直接取地址的表达式. 右值主要表示对象的值, 而非身份.
◼ 没有持久的存储位置, 不能直接取地址.
◼ 不能出现在赋值操作符的左边.
◼ 典型例子: 字面值, 返回非引用类型的函数调用, 后置自增/自减运算符, 算术/逻辑/比较表达式.


4. 将亡值
◼ 将亡值(xvalue)属于右值的一种。它表示一个即将被销毁、但其资源可以被移动的对象。
◼ 表示资源即将转移。
◼ 通常出现在使用 std::move 后或函数返回右值引用时。
◼ 支持移动语义，允许资源高效转移而无需拷贝。
◼ static_cast<T&&>, 将左值转为将亡值。


5. 左值引用
◼ 绑定到可被修改、具有持久存储的对象(左值)上。也可以通过 const T& 绑定临时对象(右值)，延长其生命周期。
◼ 用于函数参数传递，避免不必要的拷贝。
◼ 用于返回对象的引用，实现链式调用和引用返回


6. 右值引用
◼ 右值引用用于绑定右值对象(包括将亡值)，主要用于实现移动语义和完美转发。右值引用的语法形式为 T&&，其中 T 是引用的类型。
◼ 定义类的移动构造函数和移动赋值运算符，以便高效地转移资源
◼ 函数可以返回右值引用，以支持移动语义
◼ 在模板函数中，使用万能引用和 std::forward 保持参数的值类别，实现完美转发


7. 移动语义(Move Semantics)
◼ 移动语义允许资源（如动态分配的内存、文件句柄等）在对象之间高效地转移所有权，而不是进行昂贵的深拷贝。这通过移动构造函数和移动赋值运算符实现。
◼ 性能优化：减少不必要的资源拷贝，特别是在处理大型对象或资源密集型对象时显著提升效率。
◼ 资源管理：通过转移资源所有权，避免资源泄漏和双重释放的问题。
◼ 移动构造函数：接受一个右值引用（T&&），从源对象窃取资源，并将源对象置于安全的空状态。
◼ 移动赋值运算符：类似于移动构造函数，但用于已存在的对象，先释放当前资源，再转移新资源。
◼ 确保资源安全转移：在移动操作后，将源对象的资源指针置为安全的空状态（如 nullptr），避免双重释放或资源泄漏。
◼ 使用 noexcept：为移动构造函数和移动赋值运算符添加 noexcept 说明符，允许 STL 容器在需要时进行更多的优化。
◼ 禁用拷贝操作：如果移动语义是唯一允许的操作，可以通过 = delete 禁用拷贝构造函数和拷贝赋值运算符，防止意外拷贝。


8. 完美转发(Perfect Forwarding)
◼ 完美转发是一种技术，允许模板函数将其参数以原始的值类别（左值或右值）无损地转发给另一个函数。这通过万能引用和 std::forward 实现。
◼ 泛型编程：确保模板函数能够高效且正确地处理传入的参数，无论它们是左值还是右值。
◼ 保持效率：避免不必要的拷贝或移动操作，充分利用移动语义。
◼ 万能引用：在模板中，T&& 可以绑定到左值或右值，具体取决于传入的实参。
◼ std::forward: 根据模板参数 T 的推导结果，将参数转发为左值或右值。


9. 右值引用和万能引用：
◼ 右值引用: 专门用于绑定右值，实现移动语义。绑定对象仅限右值。
◼ 万能引用(T&& 在模板中): 实现完美转发，保持参数的原始值类别。既可以绑定左值，也可以绑定右值。依赖模板类型推导和引用折叠规则。
◼ 如果一个类需要自定义拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，那么通常需要自定义所有三个。
◼ 如果一个类需要自定义拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数中的任何一个，那么它通常需要自定义所有五个。
