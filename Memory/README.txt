1. 进程虚拟地址空间布局
◼ Text段: 
    ● 包含程序的可执行代码以及只读常量等。
    ● 由于程序代码通常不需要修改，操作系统会将该区域映射为只读，并且可以实现共享(多个进程运行同一份代码时共用一块物理内存)
◼ Data段: 
    ● 存放已初始化的全局变量和静态变量; 
    ● 该区域在编译链接时已知大小，并且存储在可执行文件中
◼ BSS段: 
    ● 用于存放未初始化的全局/静态变量; 
    ● 该区域在编译链接时仅保留大小信息，运行时才被真正分配并清零，故在可执行文件中不会占据实际存储空间
◼ Heap: 
    ● 由动态分配内存（如 malloc、new）使用，堆空间向高地址增长。
    ● 程序运行时可以自由扩展或收缩堆空间(通过系统调用如 brk、sbrk 或更常见的 mmap 方式实现)
◼ 文件映射区: 
    ● 包含动态链接库(共享库)的映射区域和其他由 mmap 系统调用映射的内存区域(如内存映射文件、匿名映射等)
◼ Stack: 
    ● 存放函数调用时的局部变量、返回地址、函数参数等信息，通常向低地址方向扩展
◼ 内核空间: 
    ● 在用户态中不可直接访问内核空间(受操作系统保护)


2. C++内存模型
◼ 栈区:
    ● 栈区常被称为自动存储区(automatic storage), 在 C++ 中主要用于存储局部变量、函数参数、返回地址以及
      编译器在调用/返回过程中需要使用的其他临时信息
    ● 在函数调用时，会在栈上开辟相应大小的空间，用于存储该函数的局部变量和部分调用信息；函数返回后，这块空间被自动释放
    ● 生命周期: 在函数调用时分配，在函数返回后释放，或在花括号作用域结束时自动销毁局部对象
◼ 堆区 / 自由存储区:
    ● 堆: 在通用操作系统层面，常指使用 malloc / free 或系统调用(如 brk / mmap)动态申请和释放的内存区域
    ● 自由存储区: 专指使用 new / delete 操作符进行内存分配和释放的区域
    ● 生命周期: 由程序员决定
◼ 常量存储区
    ● 存储字符串字面量, const 修饰的只读数据等(有些编译器可能将它们放在 .rodata 段或合并到代码段)
    ● 经常与代码区一起被标记为只读(如 .text 和 .rodata)，以防止修改
    ● 生命周期: 在程序运行期间始终存在
◼ 全局 / 静态存储区
    ● 存储已初始化的全局变量和静态变量(编译期已知值), 未初始化的全局变量和静态变量(初始值为 0，通常存放于 BSS 段)
    ● 在 C++ 中，静态不仅可以修饰全局变量，也可以修饰类的静态成员、函数内部的静态局部变量等
    ● 这些变量在程序启动时被分配，在程序结束时被回收，生命周期贯穿整个程序运行期
◼ 代码区
    ● 存储内容: 包含程序的可执行指令(机器码)，以及有时会包含只读的常量(可能也会放到独立的只读区)
    ● 通常被标记为只读，防止程序在运行时修改自身的指令
    ● 可执行文件中，代码段可以被多个进程共享(操作系统会将同一个程序的代码段映射到每个进程的虚拟地址空间里)，从而节省内存
    ● 生命周期: 程序运行时一直存在，直到程序退出


3. 存储持续性，作用域和链接性
◼ 存储持续性
    ● 静态存储持续性: 对象在整个程序执行期间都存在，如全局变量、静态变量等
    ● 线程存储持续性: C++11 引入的 thread_local，在某个线程开始时分配，线程结束时销毁。
    ● 自动存储持续性: 函数或代码块作用域结束后，对象即被销毁，如局部变量存在于栈区。
    ● 动态存储持续性: 通过 new/delete 或 malloc/free 动态创建和销毁，典型分配在堆(自由存储区)
◼ 作用域
    ● 块作用域: 如函数体或花括号 {} 内，包括 if/while/for 块等
    ● 函数作用域: 用于局部变量的可见范围
    ● 命名空间作用域: 在命名空间内声明的标识符，其作用域从声明处到命名空间结束
    ● 类作用域: 在类的定义体中声明的标识符，如成员变量和成员函数，作用域在类体内
    ● 文件作用域: 在源文件最外层声明的标识符(不在任何函数或类内)，也可称为全局作用域
    ● 所有不在显式命名空间或类、结构体等作用域中声明的标识符，都属于全局命名空间
◼ 链接性
    ● 无链接: 仅在当前作用域可见，无法跨翻译单元访问。例如函数的局部变量。
    ● 内部链接: 标识符只能在当前翻译单元内可见，不能被其他翻译单元引用。可以通过在全局/命名空间作用域使用 static 声明，
            或在命名空间作用域使用 const(如 const int x = 10; 默认具有内部链接)
    ● 外部链接: 标识符可以被多个翻译单元引用，编译器/链接器会将同名标识符解析为同一个实体. 
            全局作用域下不加 static、或使用 extern 声明都可产生外部链接。
